<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Répartition des objets autour d'un point</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
<script src="https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.js"></script>
<link href="https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.css" rel="stylesheet" />
<style>
	body { margin: 0; padding: 0; }
	#map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>
<body>
<style>
.marker {
display: block;
border: none;
border-radius: 50%;
cursor: pointer;
padding: 0;
}
</style>
<div id="map"></div>
<script>
// POUR LA CARTE DE BASE AVEC MARKER, VOIR https://gitlab.huma-num.fr/bmericskay/maplibre/-/blob/master/Basemapsmenu.html
// POUR LES ICONES PERSONNALISES, VOIR https://gitlab.huma-num.fr/bmericskay/maplibre/-/blob/master/Basemapsmenu.html
// ICONE PERSONNALISEE dans le domaine public https://freesvg.org/img/15916332341591632467eco-systemedic-windmill.png
var obs_point= [4.2261, 47.6683] // le point d'observation

var poi_point=new Array( [4.2661, 47.6683],[4.2661, 47.62361183],[4.337778, 47.623611]) // les points d'interet

// calcul de la distance à partir de la latitude et de la longitude
// http://villemin.gerard.online.fr/aGeograp/Distance.htm (2e méthode loi des sinus)
// d = 6371 x arccos (sin(latitudeA)xsin(latitudeB)+cos(latitudeA)cos(latitudeB)cos(longitudeB-longitudeA)
function distance(pointA,pointB){
	this.latA=pointA[1];
	this.latB=pointB[1];
	this.lonA=pointA[0];
	this.lonB=pointB[0];
	return (6371*Math.acos(Math.sin(latA*Math.PI/180)*Math.sin(latB*Math.PI/180)+Math.cos(latA*Math.PI/180)*Math.cos(latB*Math.PI/180)*Math.cos((lonB-lonA)*Math.PI/180)));
}
window.alert(distance(obs_point,poi_point[0]))
function angle(pointA,pointB){
	// this.pointA=pointA;
	// this.pointB=pointB;
	window.alert("On est dans l'angle");
	this.latA=pointA[1];
	this.latB=pointB[1];
	this.lonA=pointA[0];
	this.lonB=pointB[0];
	// window.alert("Point A"+pointA);
	let angle;	
	// en suivant le méridien (même longitude), on a le cosinus de l angle
	let meridien=6371*Math.acos(Math.sin(latA*Math.PI/180)*Math.sin(latB*Math.PI/180)+Math.cos(latA*Math.PI/180)*Math.cos(latB*Math.PI/180));
	// en suivant le parallèle (même latitude), on a le sinus de l'angle
	let parallele=6371*Math.acos(Math.sin(latA*Math.PI/180)*Math.sin(latA*Math.PI/180)+Math.cos(latA*Math.PI/180)*Math.cos(latA*Math.PI/180)*Math.cos((lonB-lonA)*Math.PI/180));
	// on determine l angle avec le sinus et cosinus
	let anglemajeur=180*Math.acos(meridien/distance(pointA,pointB))/Math.PI; // Arccos répond dans O,PI soit 0,180
	angle=0;
	if(lonB=lonA){
				if (latB>=latA) {angle=90} else {angle=270}
				 }
		else if (latB>latA) {angle=anglemajeur} // sur 0,PI, B est au-dessus de A 
		else {angle=360-anglemajeur};
	return (angle);
}

	angle(obs_point,poi_point[0]));

//var tousazimuts=new Array;
function test(){
	angle(obs_point,poi_point[0]));
	window.alert("Azimut 0 "+angle(obs_point,poi_point[0]));
	window.alert("Azimut 1 "+angle(obs_point,poi_point[1]));
	window.alert("Azimut 2 "+angle(obs_point,poi_point[2]));
} 
test();
for(const unpoint of poi_point){
	ladistance=distance(obs_point,unpoint);
	ladirection=Math.floor(angle(obs_point,unpoint));
	// tousazimuts[angle]+=1
	window.alert("Azimut "+ladistance);
};
window.alert("on est sorti de la boucle");
// window.alert(angle(poi_point[1],poi_point[2]))
var geojson = {
'type': 'FeatureCollection',
'features': [
{
'type': 'Feature',
'properties': {
'message': 'Foo',
'iconSize': [60, 60]
},
'geometry': {
'type': 'Point',
'coordinates': poi_point[0]
}
},
{
'type': 'Feature',
'properties': {
'message': 'Bar',
'iconSize': [50, 50]
},
'geometry': {
'type': 'Point',
'coordinates': poi_point[1]
}
},
{
'type': 'Feature',
'properties': {
'message': 'Baz',
'iconSize': [40, 40]
},
'geometry': {
'type': 'Point',
'coordinates': poi_point[2]
}
}
]
};

var map = new maplibregl.Map({
container: 'map', // container id
// style: 'https://demotiles.maplibre.org/style.json', // style URL
style: 'https://geoserveis.icgc.cat/contextmaps/osm-bright.json',
center: obs_point, // starting position [lng, lat]
zoom: 8 // starting zoom = 1 mais on prend 10
});
var here_marker = new maplibregl.Marker()
.setLngLat(obs_point)
.addTo(map);

geojson.features.forEach(function (marker) {
// create a DOM element for the marker
var el = document.createElement('div');
el.className = 'poi_marker';
el.style.backgroundImage =
'url(https://placekitten.com/g/' +
marker.properties.iconSize.join('/') +
'/)';
el.style.width = marker.properties.iconSize[0] + 'px';
el.style.height = marker.properties.iconSize[1] + 'px';
 
// el.addEventListener('click', function () {
//window.alert(marker.properties.message);
// });
 
// add marker to map
new maplibregl.Marker(el)
.setLngLat(marker.geometry.coordinates)
.addTo(map);
});
</script>
 
</body>
</html>